// 1. 원시 타입 (= 불변값) -> Number, String, Boolean, Null, Undefined
let p1 = 1; // 메모리 어딘가에 1 저장 후 p1 변수가 1을 가리키도록 함
let p2 = p1; // 동일하게 메모리 어딘가에 1 저장 후 p2 변수가 1을 가리키도록 함

p2 = 2; // 2라는 값을 새로운 메모리 공간에 저장 후 p2가 2를 가리키도록 수정

/*
변수의 값을 변경하더라도 실제 메모리의 값은 수정되지 않음!!
즉, 메모리에 한 번 저장된 원본 데이터는 수정되지 않고 지속적으로 남아있음.
 */


// 2. 객체 타입 (= 가변값) -> Object, Array, Function, RegexExp
let obj1 = { name: "박윤호" }; // 메모리 어딘가에 객체 저장 후 o1 변수가 참조값(주소값)을 가리키도록 함
let obj2 = obj1; // obj1이 가리키고 있는 참조값(주소값)을 똑같이 가리키도록 함

obj2.name = "Yunho Park"; // obj2가 가리키고 있던 참조값(주소값)의 대상 객체를 수정 : { name: "박윤호" } -> { name: "Yunho Park" }

/*
원시 타입과 달리 변수(객체)의 속성을 변경하면 참조값을 통해 원래 가리키고 있던 객체를 수정!!
즉, 메모리에 저장된 원본 데이터는 지속적으로 수정됨.

[주의사항]
1. 의도치 않게 값이 수정될 수 있다. (얕은 복사 vs. 깊은 복사)
    -> obj1과 obj2는 같은 참조값을 가리키고 있으므로, obj2.name 을 수정하게 되면 obj1이 바라보고 있는 객체도 함께 수정됨.
    -> `let obj3 = { ...o1 }` 이런 식으로 깊은 복사를 통해 새로운 객체와 참조값을 생성하도록 해야함!!

2. 객체 간의 비교는 기본적으로 참조값을 기준으로 이루어진다.
    -> `obj1 === obj2` : true , `obj1 === obj3` : false
    -> `JSON.stringify(obj1) === JSON.stringify(obj3)` : true (객체를 문자열로 변환하여 프로퍼티를 비교하도록 해야함)

3. 배열(Array)과 함수(Function)도 객체이다.

 */